= Fulcro RAD Datalevin

A database adapter plugin for https://fulcro.fulcrologic.com/[Fulcro RAD] that provides support for https://github.com/juji-io/datalevin[Datalevin], an embedded Datalog database.

== Features

* Automatic schema generation from RAD attributes
* Save and delete middleware for RAD forms
* Automatic Pathom3 resolver generation
* Support for all RAD attribute types
* Connection and database management utilities
* Testing utilities with automatic cleanup (`with-temp-database` macro)
* Production-ready error handling with detailed context
* Configurable safety limits (batch sizes, timeouts, retries)
* Input validation with helpful error messages

== Installation

Add to your `deps.edn`:

[source,clojure]
----
{:deps {us.whitford/fulcro-rad-datalevin {:git/url "https://github.com/michaelwhitford/fulcro-rad-datalevin"
                                           :git/sha "LATEST_SHA"}}}
----

Or use a local checkout:

[source,clojure]
----
{:deps {us.whitford/fulcro-rad-datalevin {:local/root "/path/to/fulcro-rad-datalevin"}}}
----

== Quick Start

=== 1. Define RAD Attributes

[source,clojure]
----
(ns com.example.model.account
  (:require
    [com.fulcrologic.rad.attributes :as attr :refer [defattr]]
    [us.whitford.fulcro.rad.database-adapters.datalevin-options :as dlo]))

(defattr id :account/id :uuid
  {::attr/schema     :main
   ::attr/identity?  true})

(defattr name :account/name :string
  {::attr/schema      :main
   ::attr/identities  #{:account/id}
   ::attr/required?   true})

(defattr email :account/email :string
  {::attr/schema      :main
   ::attr/identities  #{:account/id}
   ;; Custom Datalevin schema override
   ::dlo/attribute-schema {:db/unique :db.unique/value}})

;; Enum attributes
(defattr role :account/role :enum
  {::attr/schema             :main
   ::attr/identities         #{:account/id}
   ::attr/enumerated-values  #{:admin :user :guest}
   ::attr/enumerated-labels  {:admin "Administrator"
                              :user  "Regular User"
                              :guest "Guest User"}})

(defattr status :account/status :enum
  {::attr/schema             :main
   ::attr/identities         #{:account/id}
   ;; Can use fully-qualified keywords
   ::attr/enumerated-values  #{:status/active :status/inactive}})

(defattr permissions :account/permissions :enum
  {::attr/schema             :main
   ::attr/identities         #{:account/id}
   ::attr/cardinality        :many  ;; Multiple values allowed
   ::attr/enumerated-values  #{:read :write :execute}})

(def attributes [id name email role status permissions])
----

NOTE: When querying enum attributes, use pull patterns with `:db/ident` to get the keyword value:
`(d/pull db [:account/id {:account/role [:db/ident]}] [:account/id id])` returns
`{:account/id uuid :account/role {:db/ident :account.role/admin}}`.

=== 2. Start Database Connection

[source,clojure]
----
(ns com.example.components.database
  (:require
    [us.whitford.fulcro.rad.database-adapters.datalevin :as dl]
    [com.example.model.account :as account]))

(defonce connections (atom {}))

(defn start! []
  (let [conn (dl/start-database!
               {:path       "/var/data/my-app"
                :schema     :main
                :attributes account/attributes})]
    (swap! connections assoc :main conn)))

(defn stop! []
  (doseq [[_ conn] @connections]
    (dl/stop-database! conn))
  (reset! connections {}))
----

=== 3. Configure Pathom Parser

[source,clojure]
----
(ns com.example.components.parser
  (:require
    [us.whitford.fulcro.rad.database-adapters.datalevin :as dl]
    [us.whitford.fulcro.rad.database-adapters.datalevin-options :as dlo]
    [com.fulcrologic.rad.form :as form]
    [com.wsscode.pathom3.connect.indexes :as pci]
    [com.example.model.account :as account]
    [com.example.components.database :as db]))

(def all-attributes
  (vec (concat account/attributes
               ;; other model attributes
               )))

;; Generate resolvers for specific schema
(def auto-resolvers
  (dl/generate-resolvers all-attributes :main))

(def indexes
  (pci/register
    (concat
      auto-resolvers
      ;; custom resolvers
      )))

;; Create Pathom plugin with database mapper
(def database-mapper
  (fn [_env] @db/connections))

(def pathom-plugins
  [(dl/pathom-plugin database-mapper)])

(def env
  (-> indexes
      ;; plugins will add ::dlo/connections and ::dlo/databases
      ))
----

=== 4. Configure Form Middleware

[source,clojure]
----
(ns com.example.components.middleware
  (:require
    [us.whitford.fulcro.rad.database-adapters.datalevin :as dl]
    [com.fulcrologic.rad.middleware.save-middleware :as save-mw]
    [com.fulcrologic.rad.middleware.delete-middleware :as delete-mw]))

;; Middleware wraps the base handler
(def save-middleware
  (-> identity-middleware
      (dl/wrap-datalevin-save)
      (save-mw/wrap-rewrite-values)))

(def delete-middleware
  (-> identity-middleware
      (dl/wrap-datalevin-delete)))

;; Or use 0-arity for terminal handler
(def save-middleware-terminal
  (dl/wrap-datalevin-save))

(def delete-middleware-terminal
  (dl/wrap-datalevin-delete))
----

== API Reference

=== Schema Generation

`automatic-schema`:: Generate Datalevin schema from RAD attributes
+
[source,clojure]
----
(dl/automatic-schema :main account/attributes)
;; => {:account/id {:db/valueType :db.type/uuid
;;                  :db/unique :db.unique/identity}
;;     :account/name {:db/valueType :db.type/string}
;;     :account/email {:db/valueType :db.type/string}}
----

`ensure-schema!`:: Ensure the database has the correct schema (updates if needed)
+
[source,clojure]
----
(dl/ensure-schema! conn schema-map)
----

=== Database Management

`start-database!`:: Start a database connection with automatic schema
+
[source,clojure]
----
(dl/start-database!
  {:path       "/var/data/mydb"
   :schema     :main
   :attributes all-attributes
   :auto-schema? true})
----

`stop-database!`:: Close a database connection
+
[source,clojure]
----
(dl/stop-database! conn)
----

`empty-db-connection`:: Create a temporary database for testing
+
[source,clojure]
----
(dl/empty-db-connection :main account/attributes)
----

`create-temp-database!`:: Create a temporary database with cleanup support
+
[source,clojure]
----
(let [{:keys [conn path cleanup!]} (dl/create-temp-database! :main attrs)]
  (try
    ;; use conn
    (finally (cleanup!))))
----

`with-temp-database`:: Macro for temporary database with automatic cleanup
+
[source,clojure]
----
(dl/with-temp-database [conn :main attrs]
  (d/transact! conn [...])
  (dl/q '[:find ...] (d/db conn)))
----

`seed-database!`:: Seed a database with initial data
+
[source,clojure]
----
(dl/seed-database! conn [{:account/id id :account/name "Alice"}])
----

=== Middleware

`wrap-datalevin-save`:: Form save middleware that transacts deltas to Datalevin
+
[source,clojure]
----
(def save-middleware (dl/wrap-datalevin-save))
;; or with options
(def save-middleware (dl/wrap-datalevin-save {:default-schema :main}))
----

`wrap-datalevin-delete`:: Form delete middleware that retracts entities
+
[source,clojure]
----
(def delete-middleware (dl/wrap-datalevin-delete))
----

=== Resolver Generation

`generate-resolvers`:: Generate Pathom3 resolvers from attributes
+
[source,clojure]
----
(def resolvers (dl/generate-resolvers all-attributes))
----

`id-resolver`:: Generate a single identity resolver
+
[source,clojure]
----
(dl/id-resolver account/id [account/name account/email])
----

=== Pathom3 Integration

`pathom-plugin`:: Create a Pathom3 plugin for database access
+
[source,clojure]
----
(dl/pathom-plugin connections)
----

`mock-resolver-env`:: Create mock environment for testing
+
[source,clojure]
----
(dl/mock-resolver-env {:main conn})
----

=== Query Utilities

`q`:: Execute Datalog queries
+
[source,clojure]
----
(dl/q '[:find ?e ?name
        :where [?e :account/name ?name]]
      db)
----

`pull`:: Pull entity data
+
[source,clojure]
----
(dl/pull db [:account/name :account/email] eid)
----

`pull-many`:: Pull multiple entities
+
[source,clojure]
----
(dl/pull-many db [:account/name] eids)
----

`get-by-ids`:: Fetch multiple entities by their identity attribute values
+
[source,clojure]
----
(dl/get-by-ids db :account/id [id1 id2] [:account/name :account/email])
;; => {id1 {:account/name "Alice" ...} id2 {...}}
----

=== Dynamic Configuration

The following dynamic vars control runtime behavior:

`*max-batch-size*`:: Maximum number of entities in batch queries (default: 1000)
`*transaction-timeout-ms*`:: Transaction timeout in milliseconds (default: 30000)
`*max-retries*`:: Maximum retry attempts for transient failures (default: 3)

[source,clojure]
----
(binding [dl/*max-batch-size* 500]
  (dl/get-by-ids db :account/id ids pattern))
----

== Configuration Options

The `datalevin-options` namespace provides configuration keys:

[source,clojure]
----
(require '[us.whitford.fulcro.rad.database-adapters.datalevin-options :as dlo])

;; Environment keys (used in Pathom env)
::dlo/connections  ; Map of schema -> connection
::dlo/databases    ; Map of schema -> current db value

;; Attribute-level options
::dlo/attribute-schema   ; Override Datalevin schema
::dlo/native-id?         ; Use Datalevin's internal entity IDs
::dlo/generate-resolvers? ; Disable automatic resolver generation

;; Schema options
::dlo/schema            ; Schema name for this attribute
::dlo/transact-options  ; Options passed to transact!

;; Performance and safety limits
::dlo/transaction-timeout-ms ; Timeout in milliseconds (default: 30000)
::dlo/max-retries            ; Max retry attempts (default: 3)
::dlo/max-batch-size         ; Max entities per batch query (default: 1000)
----

== Type Mapping

RAD types are automatically mapped to Datalevin types:

[cols="1,1"]
|===
| RAD Type | Datalevin Type

| `:string`
| `:db.type/string`

| `:password`
| `:db.type/string`

| `:boolean`
| `:db.type/boolean`

| `:int`
| `:db.type/long`

| `:long`
| `:db.type/long`

| `:double`
| `:db.type/double`

| `:float`
| `:db.type/float`

| `:bigdec`
| `:db.type/bigdec`

| `:instant`
| `:db.type/instant`

| `:keyword`
| `:db.type/keyword`

| `:symbol`
| `:db.type/symbol`

| `:uuid`
| `:db.type/uuid`

| `:enum`
| `:db.type/ref`

| `:ref`
| `:db.type/ref`

| `:tuple`
| `:db.type/tuple`
|===

== Error Handling

The adapter provides structured error handling with detailed context:

=== Missing Connection Errors

When a database connection is not configured for a schema, an `ex-info` exception is thrown with:

* `:schema` - the requested schema key
* `:available-schemas` - vector of configured schema keys

=== Transaction Failures

Failed transactions throw `ex-info` with:

* `:schema` - the schema where the transaction failed
* `:txn-count` - number of transaction entries
* `:error-message` - the underlying error message

=== Input Validation

Invalid delta structures are rejected with descriptive errors:

* Delta must be a map
* Each entry must have `[id-attr id]` as key
* Each change must have `:before` and `:after` keys

=== Batch Size Limits

Queries exceeding `*max-batch-size*` throw with:

* `:requested` - requested batch size
* `:maximum` - configured maximum
* `:id-attr` - the identity attribute being queried

== Differences from Datomic Adapter

Key differences from `fulcro-rad-datomic`:

* **Schema format**: Datalevin uses map-of-maps schema format, not transaction vectors
* **No temporal database**: Datalevin doesn't maintain history by default
* **Embedded database**: No separate transactor process needed
* **Connection management**: Uses `get-conn` instead of `connect`
* **Schema updates**: Schema passed at connection time, updated via `update-schema`
* **Namespace**: Uses `us.whitford.fulcro.rad.database-adapters` instead of `com.fulcrologic.rad.database-adapters`

== Development

=== Running Tests

[source,bash]
----
clj -M:run-tests
----

=== Checking for Outdated Dependencies

[source,bash]
----
clj -M:outdated
----

=== Building

[source,bash]
----
clj -X:jar
----

=== Installing Locally

[source,bash]
----
clj -X:install
----

=== Deploying

[source,bash]
----
clj -X:deploy
----

== Troubleshooting

=== Forms Don't Save or Revert After Save

**Symptoms**: Form appears to save but immediately reverts, or changes don't persist to database.

**Common Causes**:

1. **Middleware not properly configured** - Ensure middleware wraps your handler:
+
[source,clojure]
----
(def wrapped-handler
  (-> base-handler
      (dl/wrap-datalevin-save {:default-schema :main})
      (dl/wrap-datalevin-delete)))
----

2. **Missing database connection** - Verify `::dlo/connections` is in your Pathom environment:
+
[source,clojure]
----
{::dlo/connections @connections
 ::dlo/databases   (into {} (map (fn [[k v]] [k (d/db v)])) @connections)}
----

3. **Schema mismatch** - Ensure attribute schema names match connection keys:
+
[source,clojure]
----
;; Attribute defines :main
(defattr id :account/id :uuid
  {::attr/schema :main})

;; Connection must use :main
(swap! connections assoc :main conn)
----

**Debug Steps**:

1. Run the test suite to verify the adapter works: `clojure -M:run-tests`
2. If tests pass, the issue is in your app configuration
3. Add logging to verify middleware returns a map with `:tempids` key
4. Check server logs for connection errors

=== "No database connection configured for schema"

**Cause**: Your attributes reference a schema that doesn't have a connection.

**Solution**: Add the missing connection or use `default-schema`:

[source,clojure]
----
;; Option 1: Add connection
(swap! connections assoc :production conn)

;; Option 2: Use default schema in middleware
(dl/wrap-datalevin-save {:default-schema :production})
----

=== Batch Size Limit Errors

**Cause**: Trying to fetch more than 1000 entities in a single query.

**Solution**: Either paginate your queries or increase the limit:

[source,clojure]
----
(binding [dl/*max-batch-size* 5000]
  ;; your large query here
  )
----

=== Test Database Cleanup Issues

**Symptom**: `/tmp` fills up with test databases.

**Solution**: Use the `with-temp-database` macro for automatic cleanup:

[source,clojure]
----
(dl/with-temp-database [conn :test test-attributes]
  ;; test code here - database automatically cleaned up
  )
----

== License

Copyright (c) Michael Whitford

Distributed under the MIT License.
